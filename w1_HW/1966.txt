1966번: 프린터 큐

1.
현재 큐의 가장 앞에 있는 문서의 중요도를 확인한다.
나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 
이 문서를 인쇄하지 않고 큐의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄한다.
입력 : 첫 줄에 테스트 케이스 수. 
테스트 케이스 첫 줄엔 문서의 개수N, 
몇 번째로 인쇄되었는지 궁금한 문서가 현재 큐에서 몇 번째에 놓여 있는지를 나타내는M.  
두 번째 줄에는 N개 문서의 중요도가 차례로 주어진다.(중요도가 같은 문서가 있을 수 있다.) 
출력 : 각 테스트 케이스에 대해서 문서가 몇 번째로 인쇄되는지 출력. 

2. 
테스트 케이스에 대해 반복 작업 수행.
가장 앞 문서의 중요도와 큐에 남아 있는 문서의 중요도 비교.
첫 문서의 중요도가 크다면 뽑은 원소와 그 이전의 문서를 뒤로 보냄.
첫 문서가 가장 중요도가 큰 문서가 아니였다면, 다시 중요도 비교.
첫 문서가 가장 중요도가 큰 문서이고, 찾는 문서라면 테스트 케이스를 종료하고 반복수를 출력.

3. 
int test = 테스트 케이스 수
int[] out = 테스트 케이스 별 결과

for(test){
    int count = 0; //반복 횟수
    queue //링크드리스트로 큐 생성.
    int n = 문서 개수
    int m = 찾는 문서가 현재 큐에 놓여진 위치

    queue에 {문서, 중요도}를 담는다.
    
    while(!queue.isEmpty()){
        int[] front = 첫번째 문서와 중요도
        
        queue의 문서들과 front 문서 중요도 비교{
            if(queue[i] 중요도 > front 중요도){
                front는 가장 중요도가 큰 문서가 아니다.
            }
        }

        if(front가 가장 중요도가 큰 문서이면){
            if(front == m){
                break;
            }
        }else{
            queue.add(front);
        }
    }

    print(count);
}